---
title: "Session 1 — Introduction to R and the tidyverse"
author: "Matthew Taylor"
execute:
  dpi: 300
  cache: false
format: 
  html:
    toc: true
    self-contained: true
editor: visual
---

# Setup code

Before we start, run the following chunk (click the green arrow in the corner) which will check that everything we need for today's session is installed and up to date (don't worry if you don't understand the code at this point!).

```{r setup}
#| echo: false
# Required packages
required_packages <- c("tidyverse", "arrow", "babynames", "curl", "duckdb", "gapminder", 
    "ggrepel", "ggridges", "ggthemes", "hexbin", "janitor", "Lahman", 
    "leaflet", "maps", "nycflights13", "openxlsx", "palmerpenguins", 
    "repurrrsive", "tidymodels", "writexl")

# Install BiocManager if needed
if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

# Try BiocManager first, then fallback to install.packages
for (pkg in required_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    message("Trying BiocManager::install('", pkg, "')")
    tryCatch({
      BiocManager::install(pkg, ask = FALSE, update = FALSE)
    }, error = function(e_bioc) {
      message("BiocManager failed. Trying install.packages('", pkg, "')")
      tryCatch({
        install.packages(pkg, dependencies = TRUE)
      }, error = function(e_cran) {
        message("Failed to install '", pkg, "' via both methods.")
      })
    })
  }
}


```

Also, before we start, click on the little gear above the document window and select "clear all output" from the dropdown menu (this prevents any *spoilers!*):

![](images/clipboard-2730781017.png){width="590"}

# Welcome

Welcome to this three-part course on the *foundations of R for bioinformatics*. It is designed with beginners in mind, so if you already have coding experience, some sections may feel straightforward. The aim is to demystify R and show how it can be both approachable and powerful for making sense of biological data. Using real examples from bulk RNA-seq, we’ll learn how to load, explore, and visualise data, and then gradually build up to a full analysis pipeline — all within a reproducible framework using Quarto in RStudio. No prior coding experience is required. We’ll move step by step so that you finish the course confident in applying these skills to your own research.

We only have six hours together across three sessions, so the focus will be on practical foundations rather than comprehensive coverage. We’ll prioritise hands-on skills: importing data into R, working with tidy data frames, plotting with **ggplot2**, and running basic differential expression with **DESeq2**. More advanced areas — such as single-cell RNA-seq, batch correction, or complex statistical modelling — are beyond the scope of these sessions, but you’ll get resources and pointers for continuing your learning. By the end, you’ll not only have a practical toolkit for RNA-seq analysis, but also a set of plug-and-play templates you can adapt to your own data with minimal changes.

## A quick note about Quarto

Throughout this course, we’ll be using **Quarto**, a modern, flexible system for creating dynamic documents with embedded R code. (If you’ve ever used R Markdown before, Quarto will feel familiar). Quarto lets us write code, text, and plots all in one place, making it easy to produce reproducible reports, figures, and even interactive documents.

You don’t need to know anything about Quarto to get started — we’ll walk through the basics together. For now, all you need to know is that your `.qmd` file acts as your lab notebook: you can write plain English alongside R code, and Quarto will render it into a nicely formatted document with just one click.

You can also see at the top left of the document a 'source' and 'visual' tab. The *source* tab shows you the raw text and code, while the *visual* tab gives a word-processor-style view of the same content. I’d recommend keeping it in *visual* for now, as it will feel more familiar if you’re used to working in word processors.

## Sources and Inspirations

One of the main advantages of R — and all of the other tools we will be using — is that they are **open-source**. This means the code behind them is freely available for anyone to view, use, modify, and share.

Open source software is developed by communities of researchers, developers, and users who contribute their time and expertise to improve it. This approach helps science stay transparent, reproducible, and accessible — values that are especially important in bioinformatics, where data and methods evolve rapidly.

The other advantage is that there are *countless* tutorials, books, teaching resources etc explaining all aspects of the different tools we will be using. Rather than reinvent the wheel, I've drawn inspiration from a number these resources that are widely regarded for their clarity and accessibility:

-   ***R for Data Science(2nd Edition)*** **—** Hadley Wickham & Garrett Grolemund. A free and highly readable introduction to the tidyverse approach to R. This course is based on theirs but highly abbreviated due to time constraints, so it is worth checking out their original course for more in depth info. <https://r4ds.hadley.nz/intro.html>

-   ***Analysis of RNAseq data in R*** — Sheffield Bioinformatics Core. Dedicated workshop for analysing RNAseq data in R but expects basic R knowledge beforehand. <https://sbc.shef.ac.uk/rnaseq-r-online/>

-   ***Analyzing RNAseq data with DESeq2*** — Michael I. Love, Simon Anders, and Wolfgang Huber. A thorough walkthrough of bulk RNAseq analysis using the popular tool which we will use later in the course, *DESeq2*. <https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html>

## Goals for session 1:

By the end of this session, you will:

-   Become familiar with **Rstudio**, **Quarto** and running code

-   Understand the **basics** of R - variable types, vectors, matrices, **packages** and **libraries**.

-   Start to use **functions** and know where to find help for each function.

-   Explore data with the **penguins dataset** and the **tidyverse**.

-   Visualise data using **ggplot2**.

# The Basics

## Running code

If you've never done it before, then the very idea of 'coding' might be enough to give you cold sweats! But it doesn't have to intimidating. In fact, if you've ever used a calculator (which I'm sure you all have), then *congratulations -* you are a coder! You give it numbers (**input**), it applies some maths (a **function**), and it shows you the result (**output**). That’s functional programming in its simplest form.

All that is meant by 'coding' is telling a computer to do a thing, and it will attempt to do that thing exactly as you have written. The frustrating thing with coding is that the computer will attempt to do the thing exactly as you have written! It doesn't know what you *mean;* it can only run the *exact* instructions provided. This can mean that even a single spelling mistake or misplaced character can cause an error. It's annoying, but it happens to everyone (even so-called experts). The only way to overcome it is to just keep trying (and also to keep your code as simple as possible).

In our *Quarto* document, code is written in chunks, which can be inserted by pressing the little green ![](images/clipboard-1048022443.png){width="35" height="22"} just above the document. A drop-down menu appears, where you can specify the programming language (in our case, we will select 'R'). ![](images/clipboard-1337067812.png){width="376"}

The resulting chunk will look something like the below:

```{r}

```

The little `{r}` box shows that we are using the R programming language. We can type more information in that box to give the chunk a unique label (but don't use spaces). E.g.,

```{r empty-chunk}

```

Code is run (executed) by clicking the ![](images/clipboard-472830089.png){width="26" height="22"} in the top-right corner of the chunk. You can try it now with the above chunk, but nothing happens — why?

Clearly, an empty chunk is not very useful: we need to write some instructions in the chunk to tell R what we want it to do.

Continuing with the calculator theme, you can use R to perform basic calculations. If we type in 1 / 200 \* 30:

```{r maths-demo}
1 / 200 * 30
```

Nothing happens until you run the chunk with the green arrow. The results then appear in a small box beneath the code. If you are working in RStudio, you’ll also see the console below the document fill with the code you ran and its output. The same output will occur if you just type `1 / 200 * 30` directly into the console and hit enter.

We don't have to put a single line of code within each chunk. Here is an example with 2 maths equations back to back:

```{r 2-equations}
(59 + 73 + 2) / 3
sin(pi / 2)
```

When you run the chunk, notice that R executes the code line by line. This is a key idea: R reads your instructions from top to bottom and from left to right, just like you would read an English sentence. The order matters — e.g., if you try to use some function or variable before it has been defined, R won’t know what you mean.

In this example, you’ve also seen your first built-in function, `sin()`, and your first built-in variable, `pi`. R comes with many such tools ready to use. A function is always written as a name (like `sin`) followed by a pair of brackets `()`. Whatever you put inside the brackets is the *input*, and the function then returns an *output*. This input–function–output pattern is the backbone of coding in R.

If you’re ever unsure what a function does or what kind of input it expects, R has built-in help. Typing `?sin` or `help(sin)` in the console will bring up its documentation, showing you how it works and giving examples you can try out. In Rstudio, you can also use the Help window in the right sidebar:

![](images/clipboard-734125482.png){width="428"}

`pi` is just an *object* with an assigned *value*. We can find out what that is (to a certain level of significant figures) by just running a chunk with `pi` in it, or typing pi into the console and hitting enter:

```{r pi}
pi
```

*Quick note: later you might notice in some of the chunks "#\| error: TRUE"* *— don't worry about this, I am just telling Quarto that the code in a chunk willf give an error (e.g., in some of the exercises) which would break the render of the document if not acknowledged. The chunk will still run as normal if you press the green arrow in your Rstudio application.*

## Creating objects

You can create new objects with the assignment operator `<-`:

```{r x}
x <- 3 * 4
```

Running this code, it seems like nothing has happened, except you might notice that something has appeared in our 'Environment' tab on the right hand side. We now have a new variable called `x` which has the 'value' of 12. If you want to check that, you can either type `x` into the console and press enter, or run `x` in a new chunk, like we did with `pi`:

```{r what-is-x}
x
```

### Variable types in R

R classifies data into **types**. Knowing the type of a variable is important because it tells R what kinds of operations are possible.

The most common types you’ll use are:

-   **Numeric**: numbers you can do maths with. These are split into subtypes:

    -   **Double:** A double allows you to store numbers as decimals. This is the default treatment for numbers. *Examples*: `3.14`, `6.0`
    -   **Integer:** whole numbers.*Examples*: `1L`, `100L` (the `L` tells R it’s an integer).

-   **Character**: text, always written inside quotes.

    -   *Examples*: `"geneA"`, `"hello world"`

-   **Logical**: true/false values (also written as `TRUE` or `FALSE`).

    -   *Examples*: `TRUE`, `FALSE`

-   **Factor**: categorical variables with a set of defined levels (useful for grouping).

    -   *Example*: `factor(c("control", "treated", "treated"))`

You can check the type of any variable with the `class()` function. For example:

```{r classes}
x <- 42
class(x)     # numeric

y <- "geneA"
class(y)     # character

z <- TRUE
class(z)     # logical
```

Being aware of variable types will save you from many errors, because R will often refuse to combine or compare things of the “wrong” type.

## Creating objects continued

R is at its most powerful when working with **vectors** and **matrices**. You can **c**ombine multiple elements into a vector with `c()`:

```{r primes}
primes <- c(2, 3, 5, 7, 11, 13)
```

You can extract specific positions of the vector using square brackets `[]` (note that in R, position 1 is 1, not 0, unlike certain other programming languages... — if that sentence made no sense to you, don't worry! But IYKYK).

So if I want to extract the number at position 1 of the `primes` object:

```{r primes-1}
primes[1]
```

And basic arithmetic on vectors is applied to every element of the vector:

```{r primes-maths}
primes * 2

primes - 1
```

You can also arrange numbers into a **matrix**, which is like a table of rows and columns. Use the `matrix()` function, and tell R how many rows or columns you want:

```{r matrix}
# Create a matrix with numbers 1 to 6, filled by row
m <- matrix(1:6, nrow = 2, byrow = TRUE)
m
```

Just like with vectors, arithmetic is applied to every element of the matrix:

```{r matrix-maths}
m * 2

m + 10
```

And you can access parts of a matrix using row and column indices:

```{r matrix-indices}
m[1, 2]   # row 1, column 2
m[, 1]    # all rows, column 1
```

All R statements where you create objects, **assignment** statements, have the same form:

`object_name <- value`

When reading that code, say “object name gets value” in your head.

You will make lots of assignments, and `<-` is a pain to type. You can save time with RStudio’s keyboard shortcut: `Alt (option on mac) + -` (the minus sign). Notice that RStudio automatically surrounds `<-` with spaces, which is a good code formatting practice.

One other thing to note is what happened to `m` when we ran the code a couple of chunks back:

```{r}
m * 2

m + 10
```

**Question:** What did happen to `m`?

.

.

.

*Scroll down for answer*

.

.

.

.

.

.

.

.

.

*Nothing happened to `m` because we have not used the assignment operator - we have just done some function on `m` and output it in the console, but not saved the results to an object.*

If we wanted to store the result, we would either have to overwrite `m` or save the output to a new object, e.g.,:

```{r n}
n <- m * 2
# View n
n
```

## Comments

You may have noticed in some of my code chunks above the use of the `#` symbol. R will ignore any text after `#` for that line. This allows you to write **comments**, which R doesn't read but we still can. I'll sometimes include comments in examples explaining what’s happening with the code.

Comments can be helpful for briefly describing what the following code does.

```{r comments}
# create vector of primes
primes <- c(2, 3, 5, 7, 11, 13)

# multiply primes by 2
primes * 2
#> [1]  4  6 10 14 22 26
```

For short bits of code, you don’t need to comment every single line. As your scripts get longer, though, comments can be a lifesaver — they’ll help you (and anyone else reading your code) quickly remember what you were trying to do.

The most useful habit is to focus on *why* you wrote the code, rather than *what* it does. The ‘what’ and ‘how’ are usually clear from the code itself, but your reasoning is much harder to recover later. In data analysis especially, comments are a great way to sketch out your overall plan and jot down insights as they come up. Don’t worry if your comments aren’t perfect — even a short note can make a big difference when you come back weeks later.

Even if it feels like in the moment there's no way you can forget the point of your amazing new code, I promise you (first-hand experience right here) that code without comments can be an absolute nightmare to come back to if you've not been working on it for any stretch of time!

## Names

Object names must start with a letter and can only contain letters, numbers, `_`, and `.`. You want your object names to be descriptive, so you’ll need to adopt a convention for multiple words. Generally, people recommend **snake_case**, where you separate lowercase words with `_`.

Say you, for some reason, have made a really-long variable name:

```{r long-name}
this_is_a_really_long_name <- 2.5
```

This could get annoying to type out all the time (so maybe it's not a great choice of name). However, if you do insist on using it, Rstudio has a handy autocomplete feature. You may notice if you start typing that variable into the console or code chunk a little preview window will pop up: ![](images/clipboard-1285485139.png)

Pressing TAB will autocomplete the word for you.

### R doesn't know what you mean

Let's make another object:

```{r rocks}
r_rocks <- 2^3
```

And try to inspect it:

```{r error-rocks}
#| error: TRUE
r_rock
R_rocks
```

**Question:** What has happened here? Why are we getting an error?

.

.

.

.

*Scroll down for answer.*

.

.

.

.

.

.

.

.

*This illustrates the implied contract between you and R: R will do the tedious computations for you, but in exchange, you must be completely precise in your instructions. If not, you’re likely to get an error that says the object you’re looking for was not found. Typos matter; R can’t read your mind and say, “oh, they probably meant `r_rocks` when they typed `r_rock`”. Case matters; similarly, R can’t read your mind and say, “oh, they probably meant `r_rocks` when they typed `R_rocks`”.*

## Calling functions

R has a large collection of built-in functions that are called like this:

```{r functions}
#| eval: false
function_name(argument1 = value1, argument2 = value2, ...)
```

Let’s try using `seq()`, which makes regular **seq**uences of numbers. If we are unsure how to use `seq()` we can search for it in the help window (or typing `help(seq)`). Typing seq and then pressing TAB will automatically give us paired parentheses, which we need for functions.

Type the name of the first argument, `from`, and set it equal to `1`. Then, type the name of the second argument, `to`, and set it equal to `10`.

```{r seq}
seq(from = 1, to = 10)
```

We often omit the names of the first several arguments in function calls, so we can rewrite this as follows:

```{r seq-omit}
seq(1, 10)
```

R also helps us with paired quotation marks e.g., if you type `x <- "`, a pair of quotation marks will appear for you to put a string of characters inside.

```{r hello-world}
x <- "hello world"
```

Quotation marks and parentheses must always come in a pair. RStudio does its best to help you, but it’s still possible to mess up and end up with a mismatch. If this happens, R will show you the continuation character “+”:

`> x <- "hello +`

The `+` tells you that R is waiting for more input; it doesn’t think you’re done yet. Usually, this means you’ve forgotten either a `"` or a `)`. Either add the missing pair, or press ESCAPE to abort the expression and try again.

## Setting the working directory

One aspect of coding which we haven't touched on yet is the need to tell R exactly *where* on your system you are working i.e., the working directory. You will almost certainly be familiar with the idea of folders and file systems (e.g., Finder on MacOS, File Explorer on Windows...) and how to navigate them using a keyboard and mouse.

In R, we need to use 2 functions to figure out exactly where we are and where we want to be, so that we can save stuff in the right place, and load things into R from our working directory (or sub folders) if we need to.

Because the actual directory will be unique to each of you, I will have to demonstrate this in class. But the 2 functions we need are:

-   `getwd()` - tells us what our current working directory is.

-   `setwd()` - allows us to set the working directory to a place of our choosing.

```{r getwd}
# Let's see where we currently are
getwd()
```

## Packages

In order to run the code in this course, we need **4** things. If you've got this far, then you've already got 2 of them sorted: R and Rstudio. R is the actual programming language we're using, which doesn't come installed on your computer by default. R can be downloaded from [https://cloud.r-project.org](https://cloud.r-project.org/). A new major version of R comes out once a year, and there are 2-3 minor releases each year. It’s a good idea to update regularly. Upgrading can be a bit of a hassle, especially for major versions that require you to re-install all your packages, but putting it off only makes it worse.

R comes with a basic integrated development environment, or **IDE**, for programming; however, Rstudio is generally preferred as it comes with more user-friendly built-in features (and looks more like a desktop application which you will be used to). Rstudio can be downloaded from <https://posit.co/download/rstudio-desktop/>. RStudio is updated a couple of times a year, and it will automatically let you know when a new version is out, so there’s no need to check back. It’s a good idea to upgrade regularly to take advantage of the latest and greatest features.

The other **2** things we need are a collection of **packages** called the **tidyverse**, and some other additional packages. An R **package** is a collection of functions, data, and documentation that extends the capabilities of base R. Using packages is key to the successful use of R.

### The tidyverse

The majority of the packages that you will learn in this course are part of the so-called tidyverse. All packages in the tidyverse share a common philosophy of data and R programming and are designed to work together.

We have already installed the tidyverse in our setup code, but the code you would use to install this (or any other package) is a single line:

```{r install-tidyverse}
#| eval: false
install.packages("tidyverse")
```

You will not be able to use the functions, objects, or help files in a package until you load it with `library()`. For example, later on in the course we will be using the package `DESeq2`, but we have not yet installed or loaded this package. If we try to run a function from this package:

```{r deseq-error}
#| error: TRUE
DESeq(dds)
```

We get an error saying "could not find function...".

So, in order to use the tidyverse, we need to load it using `library()`. *Note that when you install packages, you provide the name in quotes. When you load packages, you don't use the quotes.*

```{r tidyverse-library}
library(tidyverse)
```

This tells you that tidyverse loads nine packages: dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble, tidyr. These are considered the **core** of the tidyverse because you’ll use them in almost every analysis.

Packages in the tidyverse change fairly frequently. You can see if updates are available by running `tidyverse_update()`.

### Other packages (KEEP THIS UPDATED)

Other packages which are not part of the tidyverse are designed with a different set of underlying principles. However, they can be very useful for solving problems in a different domain. Honestly, working in R over the few years I have done so, I have come to realise that if I have a problem I can't quite figure out how to do in R, someone has probably already made a package which helps to solve it! (Google is your friend here!).

As you tackle more data science projects with R, you’ll learn new packages and new ways of thinking about data.

We’ll use many packages from outside the tidyverse in this course. For example, we’ll use the following packages because they provide interesting datasets for us to work with in the process of learning R (also notice how you don't have to type out `install.packages()` line-by-line for each package, which would be really tedious! You can use our old friend `c()` to provide a vector of package names surrounded by "" and separated by commas):

*Note: we have already installed these in our setup chunk, so there is no need to run the following code right now.*

```{r other-packages}
#| eval: false
install.packages(
  c("arrow", "babynames", "curl", "duckdb", "gapminder", 
    "ggrepel", "ggridges", "ggthemes", "hexbin", "janitor", "Lahman", 
    "leaflet", "maps", "nycflights13", "openxlsx", "palmerpenguins", 
    "repurrrsive", "tidymodels", "writexl")
  )
```

## Exercises

# Data visualisation

R offers several systems for making graphs, but **ggplot2** is both the most versatile and the most elegant. It’s built on the *grammar of graphics* — a consistent way of describing and constructing plots. By learning this single system, you can quickly create a wide variety of visualisations without having to start from scratch each time.

In this section, you’ll learn how to use ggplot2 to bring your data to life. We’ll begin with a simple scatterplot, introducing the two core ideas that underpin every plot: aesthetic mappings and geometric objects. From there, we’ll explore how to show distributions of single variables and how to visualise relationships between two or more variables. We’ll wrap up with some practical advice on saving your plots and troubleshooting common problems.

As we are short on time, it will not be possible to cover all the features of ggplot2 — in fact, I discover new features every time I use it. There are plenty of great resources out there including this very handy [cheat sheet](https://posit.co/wp-content/uploads/2022/10/data-visualization-1.pdf). Here are a few that I found helpful making this course:

-   [***A ggplot2 tutorial for beautiful plotting in R***](https://www.cedricscherer.com/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/) ***-*** By Cedric Scherer.

-   [***R Graphics Cookbook, 2nd edition***](https://r-graphics.org/index.html) ***-*** By Wiston Chang

-   [***ggplot2: Elegant Graphics for Data Analysis (3e)***](https://ggplot2-book.org/) ***-*** By Hadley Wickham, Danielle Navarro and Thomas Lin Pedersen

The following section is an abbreviated walkthrough of the ***R for Data Science(2nd Edition)*** [Data Visualisation](https://r4ds.hadley.nz/data-visualize.html) section adapted for our needs.

## Loading required packages

In \[*The Basics*\], we installed the packages we need for this section. In order to access all of the functions and datasets we need, loading the packages using `library()` is required. We will load `tidyverse`, `palmerpenguins` which includes the `penguins` dataset containing body measurements for penguins on three islands in the Palmer Archipelago, and the `ggthemes` package, which offers a colourblind safe colour palette.

```{r loading-packages}
library(tidyverse)
library(palmerpenguins)
library(ggthemes)
```

## Overall aim

Our overall aim in this section is to explore the question *do penguins with longer flippers weigh more or less than penguins with shorter flippers?*

You might already have an inkling, but visualisation of the data will allow us to be more precise in our answers. For example, is the relationship linear/nonlinear? Does it vary by location or species?

By the end of this section, we should be able to confidently create the following graph, which displays the relationship between body mass and flipper length across 3 different species of penguin.

![](images/clipboard-969445509.png)

## The Data

Within the `palmerpenguins` package is a **data frame** called `penguins`. Think of a data frame a bit like an Excel spreadsheet - with variables in the columns and observations in the rows. `penguins` contains 344 observations collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER.

With our `penguins` dataset, a variable refers to an attribute of all the penguins, and an observation refers to all the attributes of a single penguin.

You can type `penguins` into a chunk or the console to see a preview of what this data frame looks like:

```{r penguins}
penguins
```

In the top corner of that preview, you will notice this: ![](images/clipboard-3070758854.png){width="94"}. That is telling us that our data frame is a special kind of data frame which is tidyverse friendly, a **tibble.** It has 344 rows (observations) and 8 columns (variables). Tibbles are part of the tidyverse, so they work seamlessly with packages like dplyr and ggplot2.

Two key differences from base data frames are:

-   Tibbles never change variable names or types unexpectedly.

-   When printed, they show just the first 10 rows and as many columns as fit on screen — making them easier to read.

The preview window is also useful for telling us the variable type as we learned earlier ([Variable types in R]). For example, we can see **species** is a factor ![](images/clipboard-1528439395.png){width="52"}while **bill_length_mm** is a double ![](images/clipboard-3998745827.png){width="83" height="22"}.

For an alternative view, where you can see all variables and the first few observations of each variable, use `glimpse()`, or `View(penguins)` (to open an interactive data viewer).

```{r glimpse}
glimpse(penguins)
```

```{r View}
View(penguins) # This will take you to a new tab in Rstudio
```

If you just want to see the first few rows:

```{r head}
head(penguins)
# Any guesses what command can be used for the last few rows?
```

How can we find out how many rows and columns we have? (assuming we don't already know)

```{r dim}
dim(penguins)
```

We can find out what all of the different variables are called by using `names()`:

```{r names}
names(penguins) # note this doesn't show variable type
```

We can summarise key information:

```{r summary}
summary(penguins)
```

### A brief introduction to the "pipe"

One of the most useful tools in the tidyverse is the **pipe**, which we will go into more detail on in session 2. Think of it as "take what is on the left and feed it into the function on the right." Its symbol looks like this `%>%` although you might also see it written elsewhere as `|>`. We will be using this *a lot* in future sessions, but a quick example now, suppose you wanted to count how many different animals of each species of penguin are in our dataset.

```{r first-pipe}
# take the whole penguins dataset and 'pipe' it into the function count()
penguins %>% 
  count(species)
```

Can even do this for multiple variables combined together. **Before you run the following code, stop and think: what do you predict will be the result?**

**Run the code. Is the output what you expected?**

```{r count-species-island}
penguins %>% 
  count(species, island)
```

## Creating the plot step-by-step

### The plot object

Plots are created in ggplot2 by assembling **layers** on top of a plot object. The first input which the `ggplot()` function expects is the data we are plotting, so let's give it the `penguins` dataset as our data. We can either do this by typing `ggplot(data = penguins)` or we can use a pipe. I am going to show you using the pipe method as it has one very useful consequence which we will see in a moment!

```{r}
penguins %>% 
  ggplot()
```

Well that was underwhelming! But do not panic. What we have done there is simply create a **plot object**. It's basically telling ggplot2 to create a canvas and expect data from our `penguins` dataset to be painted onto it.

### Mapping and aesthetics

Next, we need to tell `ggplot()` how the information from our data will be visually represented. The `mapping` argument of the `ggplot()` function defines how variables in your dataset are mapped to visual properties (**aesthetics**) of your plot. The `mapping` argument is always defined in the `aes()` function, and the `x` and `y` arguments of `aes()` specify which variables to map to the x and y axes.

For now, we will only map flipper length to the `x` aesthetic and body mass to the `y` aesthetic (but feel free to experiment with any of the others you like by editing the variables in the mapping). *Remember, you can use `names(penguins)` if you can't remember the exact spelling of all the variables — as always, spelling matters!* But I can now reveal the key advantage of using the pipe method: because ggplot is already aware it has to look inside `penguins` (left hand side of the pipe), as you start typing `x = ...` it will pop-up with a preview of the variable name, so you can just hit TAB to autocomplete. Handy!

![](images/clipboard-146528764.png)

```{r}
penguins %>% 
  ggplot(mapping = aes(x = flipper_length_mm, y = body_mass_g))
```

Our canvas now has a structure - we can see that flipper length will be on the x-axis and body mass on the y-axis. We also already can see some axis ticks, as ggplot has looked at our data and determined the appropriate x and y min and maxes automatically depending on the range. But *where are our penguins*?! They are nowhere to be seen because we have not defined *how* we want them represented.

To do so, we need to define a **geom**: the geometrical object that a plot uses to represent data. These geometric objects are made available in ggplot2 with functions that start with `geom_`. People often describe plots by the type of geom that the plot uses. For example, bar charts use bar geoms (`geom_bar()`), line charts use line geoms (`geom_line()`), boxplots use boxplot geoms (`geom_boxplot()`), scatterplots use point geoms (`geom_point()`), and so on. More information on any of these can be found in the Help window or by using the `help()` function. There are loads more geoms than we can cover in these sessions - you can find them in the cheat sheet I linked earlier.

The function [`geom_point()`](https://ggplot2.tidyverse.org/reference/geom_point.html) adds a layer of points to your plot, which creates a scatterplot. You can add layers on top of each other...but more on that later. In order to add a geom, you have to use the `+` symbol, and it's good formatting practice to then start on a new line:

```{r}
penguins %>% 
  ggplot(mapping = aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()
```

That's starting to look more like a scatterplot, and it helps us start to understand the relationship between body mass and flipper length. The relationship appears to be positive (as flipper length increases, so does body mass), fairly linear (the points are clustered around a line instead of a curve), and moderately strong (there isn’t too much scatter around such a line). Penguins with longer flippers are generally larger in terms of their body mass. We still have a way to go before we reach the plot we were aiming for but it is a good start.

You will notice that we had a **warning**: "Removed 2 rows containing missing values or values outside the scale range (\`geom_point()\`)." This isn’t an error — it’s ggplot2 letting you know that some data points couldn’t be plotted because they were missing (`NA`).

Like R, ggplot2 subscribes to the philosophy that missing values should never silently go missing. This type of warning is probably one of the most common types of warnings you will see when working with real data – missing values are a very common issue.

In practice, you’ll often need to decide what to do with missing values — for example, remove them with `na.omit()`, replace them with a sensible default, or model around them. For now, it’s enough to notice when they appear and to understand why ggplot2 draws your attention to them.

### Adding more aesthetics and layers

While scatterplots can show the relationship between 2 variables, they may mask the contribution of other variables to the relationship. Remember our earlier question: *"Does it vary by location or species?"*

We can incoporate this into our plot by modifying our aesthetics mapping to include this information. **Pause for a moment: how could we represent species on our plot?**

.

.

.

.

*Scroll down for answer*

.

.

.

.

.

.

.

.

.

The simplest method would be to colour our points according to the different species. We already know from some of our data viewing that we have 3 different species, so we know we aren't going to run out of colours!

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>% 
  ggplot(mapping = aes(x = flipper_length_mm, y = body_mass_g, colour = species)) +
  geom_point()
```

When a categorical variable is mapped to an aesthetic, ggplot2 will automatically assign a unique value of the aesthetic (here a unique colour) to each unique level of the variable (each of the three species), a process known as **scaling**. ggplot2 will also add a legend that explains which values correspond to which levels.

Now let’s add one more layer: a smooth curve displaying the relationship between body mass and flipper length. **Pause point**: **refer back to the code above, and think about how we can add this to our existing plot. Is it an aesthetic, or a new geom?.**

.

.

.

.

*Scroll down for answer*

.

.

.

.

.

.

.

.

.

.

Since this is a new geometric object representing our data, we will add a new geom as a layer on top of our point geom: `geom_smooth()`. Remember we need to do this by including the `+` sign after the previous geom. And we will specify that we want to draw the line of best fit based on a `l`inear `m`odel with `method = "lm"`.

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>% 
  ggplot(mapping = aes(x = flipper_length_mm, y = body_mass_g, colour = species)) +
  geom_point() +
  geom_smooth(method = "lm") # see help(geom_smooth) for other options
  
```

Nice! We have added lines to our data, but you'll notice there is now one line per species. Is this what we wanted?

### Global *vs* local mapping

Our "goal" plot only had one line going through the whole dataset.

This is where we get more into the weeds on aesthetic mapping. When we use the `mapping =` argument within the `ggplot()` function, we are defining things at the *global* level, i.e., in the entire plot. So in the above graph, here is how R is understanding what we want in a step-by-step manner (R reads from left-to-right, top-to-bottom):

1.  `penguins %>% ggplot(`: "Take the penguins dataset and feed it into the ggplot() function on the right."

2.  `ggplot(mapping = aes(x = flipper_length_mm, y = body_mass_g, colour = species))`: "In the entire plot, every subsequent layer (geom) needs to plot flipper_length_mm on the x axis, body_mass_g on the y axis, and colour by the species."

3.  `geom_point()`: "make points which have flipper_length_mm on the x axis, body_mass_g on the y axis, and are colourd by the species."

4.  `geom_smooth(method = "lm")`: "make a smooth line of best fit for the dataset, coloured by species (so I will need one line per species) with flipper_length_mm on the x axis and body_mass_g on the y axis."

So because `colour = species` is specified globally, each subsequent layer will be plot on a species-by-species basis (which in the case of our line of best fit, we don't want!). How to solve this?

Fortunately, every geom inside ggplot can accept a *local* mapping that are added to those inherited from the global level. Since we want points to be coloured based on species but don’t want the lines to be separated out for them, we should specify `colour = species` for `geom_point()` only:

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>% 
  ggplot(mapping = aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(mapping = aes(colour = species)) + # moving our colour mapping into geom_point() only
  geom_smooth(method = "lm")
```

We now have something that looks very much like our ultimate goal, though it’s not yet perfect. We still need to use different shapes for each species of penguins and improve labels.

It’s generally not a good idea to represent information using only colours on a plot, as people perceive colours differently due to colour blindness or other colour vision differences. Therefore, in addition to colour, we can also map `species` to the `shape` aesthetic. (This demonstrates another important point which is that multiple different aesthetics can share the same mapping).

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>% 
  ggplot(mapping = aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(mapping = aes(colour = species, shape = species)) +
  geom_smooth(method = "lm")
```

The legend handily updates itself to include shape information also.

### Changing labels and putting it all together

And finally, we can improve the labels of our plot using the `labs()` function in a new layer. Some of the arguments to `labs()` might be self explanatory: `title` adds a title and `subtitle` adds a subtitle to the plot. Other arguments match the aesthetic mappings, `x` is the x-axis label, `y` is the y-axis label, and `colour` and `shape` define the label for the legend. In addition, we can improve the colour palette to be colourblind safe with the `scale_colour_colourblind()` function from the `ggthemes` package.

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>% 
  ggplot(mapping = aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(mapping = aes(colour = species, shape = species)) +
  geom_smooth(method = "lm") +
  labs(
    title = "Body mass and flipper length",
    subtitle = "Dimensions for Adelie, Chinstrap, and Gentoo Penguins",
    x = "Flipper length (mm)", y = "Body mass (g)",
    color = "Species", shape = "Species"
  ) +
  scale_color_colorblind()
```

We finally have a plot that perfectly matches our goal plot!

## Visualising distributions

How you visualise the distribution of a variable depends on its type: **categorical** or **numerical**. When we get on to the RNAseq part of the course, we will encounter both. For example, *categorical variables* might include sample groups such as “control” vs. “treated,” while *numerical variables* could be gene expression counts, library sizes, or quality scores.

Different plot types highlight different aspects of the data — bar plots are useful for comparing counts across categories, while histograms, boxplots, or density plots are better for showing the spread of numerical values. Choosing the right type of plot is therefore very important.

### Categorical variables

A variable is **categorical** if it can only take one of a small set of values. To examine the distribution of a categorical variable, you can use a bar chart. **What geom do we use for this?**

The height of the bars displays how many observations occurred with each `x` value. *Note: with ggplot, you don't actually have to write `mapping = aes`* *every time.*

```{r}
penguins %>%
  ggplot(aes(x = species)) +
    geom_bar()
```

Categorical data, such as species in our case, is **non-ordinal** i.e., there is no natural order to it. There is no good reason why it should go Adelie, Chinstrap, then Gentoo (except for alphabetical order). We might prefer to reorder based on the count such that the frequency decreases from left to right. To do this, we transform the variable to a factor (if it isn't already) — this is how R handles categorical data. We can then reorder the levels of that factor. We will return to this concept throughout the rest of the course.

There are 2 ways we can do this, either manually or automatically.

The manual way would be to specify the factor levels ourselves:

```{r}
penguins$species <- factor(penguins$species, levels = c("Adelie", "Gentoo", "Chinstrap")) # using $ allows us to select a specific variable in penguins

unique(penguins$species) # unique means we are just looking at unique occurances rather than printing the entire species column!
```

You can now see the levels specified in the order we selected.

The automatic way is to use built-in functions which deal with factors directly in our `ggplot()` function:

```{r}
penguins %>%
  ggplot(aes(x = fct_infreq(species))) +
  geom_bar()
```

### Numerical variables

Numerical variables are quantitative, ordinal and can have maths operations performed on them. They can be continuous (e.g., height) or discrete (e.g., number of children).

One commonly used visualization for distributions of continuous variables is a histogram. **Any guesses what geom we use here?**

.

.

.

.

*Scroll down for answer*

.

.

.

.

.

.

.

.

.

.

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>%
  ggplot(aes(x = body_mass_g)) + 
    geom_histogram(binwidth = 200)
```

A histogram divides the x-axis into equal-sized bins and uses the height of each bar to show how many observations fall within that range. For example, in the plot above the tallest bar indicates that 39 penguins have a body mass between 3,500 and 3,700 grams — the left and right edges of that bin.

The `binwidth` argument controls the size of these intervals, measured in the same units as the x-axis variable. It’s good practice to experiment with different binwidths, because the choice can strongly affect what patterns you see. If the binwidth is too small (e.g. 20), the histogram becomes cluttered with many tiny bars, making the overall distribution hard to interpret. If the binwidth is too large (e.g. 2,000), the data collapse into just a few bars, again obscuring the shape of the distribution. A binwidth of around 200 in this example strikes a sensible balance, showing both detail and overall structure.

*Note: in a Quarto document, when you make 2 or more plots within the same chunk, they are presented in different tabs. We will come to different ways of presenting plots (e.g., side-by-side, over-under) using the* `patchwork` *package later.*

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>%
  ggplot(aes(x = body_mass_g)) + 
    geom_histogram(binwidth = 20)

penguins %>%
  ggplot(aes(x = body_mass_g)) + 
    geom_histogram(binwidth = 2000)
```

An alternative visualization for distributions of numerical variables is a density plot. A density plot is a smoothed-out version of a histogram and a practical alternative, particularly for continuous data that comes from an underlying smooth distribution.

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>%
  ggplot(aes(x = body_mass_g)) + 
    geom_density()
```

## Visualising relationships

When we talk of visualising relationships, we are essentially asking how different variables in our data interact with each other. This means we need at least 2 variables mapped to the aesthetics of our plot.

### A numerical and a categorical variable

For this, we can use a **boxplot**, which you may already be familiar with. A boxplot contains:

-   A box showing the interquartile range (IQR) which stretches from the 25th to the 75th percentile. The middle of a box contains a line depicting the median. These three lines give you a sense of the spread of the distribution and whether or not the distribution is symmetric about the median or skewed to one side.

-   Visual points that display observations that fall more than 1.5 times the IQR from either edge of the box. These outlying points are unusual so are plotted individually.

-   A line (or whisker) that extends from each end of the box and goes to the farthest non-outlier point in the distribution.

**Have a go at plotting body mass by species using a boxplot. You can scroll down for the answer if you get stuck.**

```{r}

```

*.*

*.*

*.*

*.*

*Scroll down for answer*

.

.

.

.

.

.

.

.

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>%
  ggplot(aes(x = species, y = body_mass_g)) +
  geom_boxplot()
```

Alternatively, we can make density plots with `geom_density()`. **How might we need to change aes?**

```{r}

```

*.*

*.*

*.*

*.*

*Scroll down for answer*

.

.

.

.

.

.

.

.

.

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>%
  ggplot(aes(x = body_mass_g, colour = species)) +
  geom_density(linewidth = 0.75) # customising line width to make it stand out a bit more
```

We’ve also adjusted the line thickness with the `linewidth` argument to help the curves stand out more clearly against the background.

In addition, we’ve mapped `species` to both the `colour` and `fill` aesthetics, and controlled the transparency of the filled density curves with the `alpha` aesthetic. `alpha` takes values from 0 (fully transparent) to 1 (fully opaque); here it’s set to 0.5.

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>%
  ggplot(aes(x = body_mass_g, colour = species, fill = species)) +
  geom_density(alpha = 0.5)
```

**The** **key idea is this:** we *map* variables to aesthetics when we want that visual property (like colour, fill, or size) to change according to the data. Otherwise, we *set* aesthetics to fixed values.

### Two categorical variables

In our data, we have a number of categorical variables, such as `species` and `island`. How could we visualise the distribution of species within each island?

One method is to use a stacked bar graph. You can just use `geom_bar()` for this, there isn't a specific geom for stacked bars.

```{r}
penguins %>%
  ggplot(aes(x = island, fill = species)) + # map variable that will be separated into bars to the x aesthetic, and the fill colour variable to the fill aesthetic 
  geom_bar()
```

This plot shows absolute values. But we can also look at the relative frequencies of the species per island by using the `position = "fill"` argument inside `geom_bar()` - I appreciate this isn't the most intuitive thing but this is where it's always worth just playing around with different settings in the geoms to see how things change. And we always have the Help window to consult if necessary. (We would have figured this out if we had gone to the help page of `geom_bar`, scrolled down to the information on position, and *then* clicked through to the "layer position" documentation page).

Using this plot we can see that Gentoo penguins all live on Biscoe island and make up roughly 75% of the penguins on that island, Chinstrap all live on Dream island and make up roughly 50% of the penguins on that island, and Adelie live on all three islands and make up all of the penguins on Torgersen.

```{r}
penguins %>%
  ggplot(aes(x = island, fill = species)) +
  geom_bar(position = "fill")
```

### Two numerical variables

We've already done this once before when we looked at flipper length *vs* body mass. A scatterplot is probably the most commonly used plot for visualizing the relationship between two numerical variables. Here is one of the plots we created earlier:

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>% 
  ggplot(mapping = aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()
```

**What other numerical variables are in our data that we could compare against each other?**

.

.

.

.

*Scroll down for answer*

.

.

.

.

.

.

.

.

```{r}
penguins
```

Example answer: bill length *vs* flipper length

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>% 
  ggplot(mapping = aes(x = flipper_length_mm, y = bill_length_mm)) +
  geom_point()
```

Our data suddenly looks a bit different. Can we figure out what is going on?

**If we have time...**

Try adding in a line of best fit and species information like we did before. What do you notice?

```{r}

```

### Three or more variables

As we saw earlier, we can incorporate more variables into a plot by mapping them to additional aesthetics. For example, in the following scatterplot the colours of points represent species and the shapes of points represent islands.

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>%
  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = island))
```

However now things are starting to get quite confusing. Remember the point of all this — we are visualising our data to see if we can spot relationships. If things are starting to get cluttered and we are overwhelmed with information, we have lost the plot (literally).

Fortunately, we can fix this to be much neater. One way, which is particularly useful for categorical variables (such as `island`) is to use **facets**, which are sub-plots that each display one subset of the data.

You can split your plot into small panels based on a variable using `facet_wrap()`. Just write `~` followed by the variable name (for example, `~island`). The variable you use should be categorical, because each category will get its own panel.

```{r}
#| warning: FALSE # suppressing that warning message
penguins %>%
  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = species))+
  facet_wrap(~island)
```

## Saving plots

We will cover the different options we have available in R for saving plots more during the session. But if you want to save a plot as an image in your current working directory, you can use the `ggsave()` function, which will save the plot most recently created to disk:

```{r}
#| eval: false
#| warning: false

penguins %>% 
  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()
ggsave(filename = "penguin-plot.png")
```

If you don’t specify the `width` and `height` they will be taken from the dimensions of the current plotting device. For reproducible code, you’ll want to specify them. You can learn more about `ggsave()` in the Help section or by using `help(ggsave)`.

## Exercises

# Summary

In this first session, we:

-   Learned how to run code in **Quarto** and use the console.

-   Created **objects** in R, explored basic variable types, vectors, and matrices.

-   Saw how to use **functions** (and get help with `?function_name`).

-   Started exploring data with the **penguins dataset** and the **tidyverse**.

-   Made our first plots in **ggplot2**, including histograms, aesthetics, and facets

In the next session, we will start learning how to import, tidy, and transform data, which will leave you in good stead for handling typical data you will encounter in a bulk RNAseq experiment.
