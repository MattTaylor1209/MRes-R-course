---
title: "Session 1 — Introduction to R and the tidyverse"
author: "Matthew Taylor"
execute:
  dpi: 300
format: 
  html:
    code-fold: true
    toc: true
    self-contained: true
editor: visual
---

# Setup code

Before we start, run the following chunk (click the green arrow in the corner) which will check that everything we need for today's session is installed and up to date (don't worry if you don't understand the code at this point!).

```{r setup}
#| echo: false
# Required packages
required_packages <- c("tidyverse", "arrow", "babynames", "curl", "duckdb", "gapminder", 
    "ggrepel", "ggridges", "ggthemes", "hexbin", "janitor", "Lahman", 
    "leaflet", "maps", "nycflights13", "openxlsx", "palmerpenguins", 
    "repurrrsive", "tidymodels", "writexl")

# Install BiocManager if needed
if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

# Try BiocManager first, then fallback to install.packages
for (pkg in required_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    message("Trying BiocManager::install('", pkg, "')")
    tryCatch({
      BiocManager::install(pkg, ask = FALSE, update = FALSE)
    }, error = function(e_bioc) {
      message("BiocManager failed. Trying install.packages('", pkg, "')")
      tryCatch({
        install.packages(pkg, dependencies = TRUE)
      }, error = function(e_cran) {
        message("Failed to install '", pkg, "' via both methods.")
      })
    })
  }
}

```

# Welcome

Welcome to this three-part course on the foundations of R for bioinformatics. It is designed with beginners in mind, so if you already have coding experience, some sections may feel straightforward. The aim is to demystify R and show how it can be both approachable and powerful for making sense of biological data. Using real examples from bulk RNA-seq, we’ll learn how to load, explore, and visualise data, and then gradually build up to a full analysis pipeline — all within a reproducible framework using Quarto in RStudio. No prior coding experience is required. We’ll move step by step so that you finish the course confident in applying these skills to your own research.

We only have six hours together across three sessions, so the focus will be on practical foundations rather than comprehensive coverage. We’ll prioritise hands-on skills: importing data into R, working with tidy data frames, plotting with **ggplot2**, and running basic differential expression with **DESeq2**. More advanced areas — such as single-cell RNA-seq, batch correction, or complex statistical modelling — are beyond the scope of these sessions, but you’ll get resources and pointers for continuing your learning. By the end, you’ll not only have a practical toolkit for RNA-seq analysis, but also a set of plug-and-play templates you can adapt to your own data with minimal changes.

## A quick note about Quarto

Throughout this course, we’ll be using **Quarto**, a modern, flexible system for creating dynamic documents with embedded R code. If you’ve ever used R Markdown before, Quarto will feel familiar — think of it as the next generation, with a few more features and a slightly cleaner setup. Quarto lets us write code, text, and plots all in one place, making it easy to produce reproducible reports, figures, and even interactive documents.

You don’t need to know anything about Quarto to get started — we’ll walk through the basics together. For now, all you need to know is that your `.qmd` file acts as your lab notebook: you can write plain English alongside R code, and Quarto will render it into a nicely formatted document with just one click.

You can also see at the top left of the document a 'source' and 'visual' tab. The *source* tab shows you the raw text and code, while the *visual* tab gives a word-processor-style view of the same content. I’d recommend keeping it in *visual* for now, as it will feel more familiar if you’re used to working in word processors.

## Sources and Inspirations

One of the main advantages of R — and all of the other tools we will be using — is that they are **open-source**. This means the code behind them is freely available for anyone to view, use, modify, and share.

Open source software is developed by communities of researchers, developers, and users who contribute their time and expertise to improve it. This approach helps science stay transparent, reproducible, and accessible — values that are especially important in bioinformatics, where data and methods evolve rapidly.

The other advantage is that there are *countless* tutorials, books, teaching resources etc explaining all aspects of the different tools we will be using. Rather than reinvent the wheel, I've drawn inspiration from a number these resources that are widely regarded for their clarity and accessibility:

-   ***R for Data Science(2nd Edition)*** **—** Hadley Wickham & Garrett Grolemund. A free and highly readable introduction to the tidyverse approach to R. This course is based on theirs but highly abbreviated due to time constraints, so it is worth checking out their original course for more in depth info. <https://r4ds.hadley.nz/intro.html>

-   ***Analysis of RNAseq data in R*** — Sheffield Bioinformatics Core. Dedicated workshop for analysing RNAseq data in R but expects basic R knowledge beforehand. <https://sbc.shef.ac.uk/rnaseq-r-online/>

-   ***Analyzing RNAseq data with DESeq2*** — Michael I. Love, Simon Anders, and Wolfgang Huber. A thorough walkthrough of bulk RNAseq analysis using the popular tool which we will use later in the course, *DESeq2*. <https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html>

# The basics

## Running code

If you've never done it before, then the very idea of 'coding' might be enough to give you cold sweats! But it doesn't have to intimidating. In fact, if you've ever used a calculator (which I'm sure you all have), then *congratulations -* you are a coder! You give it numbers (**input**), it applies some maths (a **function**), and it shows you the result (**output**). That’s functional programming in its simplest form.

All that is meant by 'coding' is telling a computer to do a thing, and it will attempt to do that thing exactly as you have written. The frustrating thing with coding is that the computer will attempt to do the thing exactly as you have written! It doesn't know what you *mean;* it can only run the *exact* instructions provided. This can mean that even a single spelling mistake or misplaced character can cause an error. It's annoying, but it happens to everyone (even so-called experts). The only way to overcome it is to just keep trying (and also to keep your code as simple as possible).

In our *Quarto* document, code is written in chunks, which can be inserted by pressing the little green ![](images/clipboard-1048022443.png){width="35" height="22"} just above the document. A drop-down menu appears, where you can specify the programming language (in our case, we will select 'R'). ![](images/clipboard-1337067812.png){width="376"}

The resulting chunk will look something like the below:

```{r}

```

The little `{r}` box shows that we are using the R programming language. We can type more information in that box to give the chunk a unique label (but don't use spaces). E.g.,

```{r empty-chunk}

```

Code is run (executed) by clicking the ![](images/clipboard-472830089.png){width="26" height="22"} in the top-right corner of the chunk. You can try it now with the above chunk, but nothing happens — why?

Clearly, an empty chunk is not very useful: we need to write some instructions in the chunk to tell R what we want it to do.

Continuing with the calculator theme, you can use R to perform basic calculations. If we type in 1 / 200 \* 30:

```{r maths-demo}
1 / 200 * 30
```

Nothing happens until you run the chunk with the green arrow. The results then appear in a small box beneath the code. If you are working in RStudio, you’ll also see the console below the document fill with the code you ran and its output. The same output will occur if you just type `1 / 200 * 30` directly into the console and hit enter.

We don't have to put a single line of code within each chunk. Here is an example with 2 maths equations back to back:

```{r 2-equations}
(59 + 73 + 2) / 3
sin(pi / 2)
```

When you run the chunk, notice that R executes the code line by line. This is a key idea: R reads your instructions from top to bottom and from left to right, just like you would read an English sentence. The order matters — e.g., if you try to use some function or variable before it has been defined, R won’t know what you mean.

In this example, you’ve also seen your first built-in function, `sin()`, and your first built-in variable, `pi`. R comes with many such tools ready to use. A function is always written as a name (like `sin`) followed by a pair of brackets `()`. Whatever you put inside the brackets is the *input*, and the function then returns an *output*. This input–function–output pattern is the backbone of coding in R.

If you’re ever unsure what a function does or what kind of input it expects, R has built-in help. Typing `?sin` or `help(sin)` in the console will bring up its documentation, showing you how it works and giving examples you can try out. In Rstudio, you can also use the Help window in the right sidebar:

![](images/clipboard-734125482.png){width="428"}

`pi` is just an *object* with an assigned *value*. We can find out what that is (to a certain level of significant figures) by just running a chunk with `pi` in it, or typing pi into the console and hitting enter:

```{r pi}
pi
```

*Quick note: later you might notice in some of the chunks "#\| error: TRUE"* *— don't worry about this, I am just telling Quarto that the code in a chunk willf give an error (e.g., in some of the exercises) which would break the render of the document if not acknowledged. The chunk will still run as normal if you press the green arrow in your Rstudio application.*

## Creating objects

You can create new objects with the assignment operator `<-`:

```{r x}
x <- 3 * 4
```

Running this code, it seems like nothing has happened, except you might notice that something has appeared in our 'Environment' tab on the right hand side. We now have a new variable called `x` which has the 'value' of 12. If you want to check that, you can either type `x` into the console and press enter, or run `x` in a new chunk, like we did with `pi`:

```{r what-is-x}
x
```

### Variable types in R

R classifies data into **types**. Knowing the type of a variable is important because it tells R what kinds of operations are possible.

The most common types you’ll use are:

-   **Numeric**: numbers you can do maths with.

    -   *Examples*: `3.14`, `42`, `-7`

-   **Character**: text, always written inside quotes.

    -   *Examples*: `"geneA"`, `"hello world"`

-   **Logical**: true/false values (also written as `TRUE` or `FALSE`).

    -   *Examples*: `TRUE`, `FALSE`

-   **Integer**: whole numbers (like numeric but restricted to integers).

    -   *Examples*: `1L`, `100L` (the `L` tells R it’s an integer).

-   **Factor**: categorical variables with a set of defined levels (useful for grouping).

    -   *Example*: `factor(c("control", "treated", "treated"))`

You can check the type of any variable with the `class()` function. For example:

```{r classes}
x <- 42
class(x)     # numeric

y <- "geneA"
class(y)     # character

z <- TRUE
class(z)     # logical
```

Being aware of variable types will save you from many errors, because R will often refuse to combine or compare things of the “wrong” type.

## Creating objects continued

R is at its most powerful when working with **vectors** and **matrices**. You can **c**ombine multiple elements into a vector with `c()`:

```{r primes}
primes <- c(2, 3, 5, 7, 11, 13)
```

You can extract specific positions of the vector using square brackets `[]` (note that in R, position 1 is 1, not 0, unlike certain other programming languages... — if that sentence made no sense to you, don't worry! But IYKYK).

So if I want to extract the number at position 1 of the `primes` object:

```{r primes-1}
primes[1]
```

And basic arithmetic on vectors is applied to every element of the vector:

```{r primes-maths}
primes * 2

primes - 1
```

You can also arrange numbers into a **matrix**, which is like a table of rows and columns. Use the `matrix()` function, and tell R how many rows or columns you want:

```{r matrix}
# Create a matrix with numbers 1 to 6, filled by row
m <- matrix(1:6, nrow = 2, byrow = TRUE)
m
```

Just like with vectors, arithmetic is applied to every element of the matrix:

```{r matrix-maths}
m * 2

m + 10
```

And you can access parts of a matrix using row and column indices:

```{r matrix-indices}
m[1, 2]   # row 1, column 2
m[, 1]    # all rows, column 1
```

All R statements where you create objects, **assignment** statements, have the same form:

`object_name <- value`

When reading that code, say “object name gets value” in your head.

You will make lots of assignments, and `<-` is a pain to type. You can save time with RStudio’s keyboard shortcut: `Alt (option on mac) + -` (the minus sign). Notice that RStudio automatically surrounds `<-` with spaces, which is a good code formatting practice.

One other thing to note is what happened to `m` when we ran the code a couple of chunks back:

```{r}
m * 2

m + 10
```

**Question:** What did happen to `m`?

*Nothing happened to `m` because we have not used the assignment operator - we have just done some function on `m` and output it in the console, but not saved the results to an object.*

If we wanted to store the result, we would either have to overwrite `m` or save the output to a new object, e.g.,:

```{r n}
n <- m * 2
# View n
n
```

## Comments

You may have noticed in some of my code chunks above the use of the `#` symbol. R will ignore any text after `#` for that line. This allows you to write **comments**, which R doesn't read but we still can. I'll sometimes include comments in examples explaining what’s happening with the code.

Comments can be helpful for briefly describing what the following code does.

```{r comments}
# create vector of primes
primes <- c(2, 3, 5, 7, 11, 13)

# multiply primes by 2
primes * 2
#> [1]  4  6 10 14 22 26
```

For short bits of code, you don’t need to comment every single line. As your scripts get longer, though, comments can be a lifesaver — they’ll help you (and anyone else reading your code) quickly remember what you were trying to do.

The most useful habit is to focus on *why* you wrote the code, rather than *what* it does. The ‘what’ and ‘how’ are usually clear from the code itself, but your reasoning is much harder to recover later. In data analysis especially, comments are a great way to sketch out your overall plan and jot down insights as they come up. Don’t worry if your comments aren’t perfect — even a short note can make a big difference when you come back weeks later.

Even if it feels like in the moment there's no way you can forget the point of your amazing new code, I promise you (first-hand experience right here) that code without comments can be an absolute nightmare to come back to if you've not been working on it for any stretch of time!

## Names

Object names must start with a letter and can only contain letters, numbers, `_`, and `.`. You want your object names to be descriptive, so you’ll need to adopt a convention for multiple words. Generally, people recommend **snake_case**, where you separate lowercase words with `_`.

Say you, for some reason, have made a really-long variable name:

```{r long-name}
this_is_a_really_long_name <- 2.5
```

This could get annoying to type out all the time (so maybe it's not a great choice of name). However, if you do insist on using it, Rstudio has a handy autocomplete feature. You may notice if you start typing that variable into the console or code chunk a little preview window will pop up: ![](images/clipboard-1285485139.png)

Pressing TAB will autocomplete the word for you.

### R doesn't know what you mean

Let's make another object:

```{r rocks}
r_rocks <- 2^3
```

And try to inspect it:

```{r error-rocks}
#| error: TRUE
r_rock
R_rocks
```

**Question:** What has happened here? Why are we getting an error?

*This illustrates the implied contract between you and R: R will do the tedious computations for you, but in exchange, you must be completely precise in your instructions. If not, you’re likely to get an error that says the object you’re looking for was not found. Typos matter; R can’t read your mind and say, “oh, they probably meant `r_rocks` when they typed `r_rock`”. Case matters; similarly, R can’t read your mind and say, “oh, they probably meant `r_rocks` when they typed `R_rocks`”.*

## Calling functions

R has a large collection of built-in functions that are called like this:

```{r functions}
function_name(argument1 = value1, argument2 = value2, ...)
```

Let’s try using `seq()`, which makes regular **seq**uences of numbers. If we are unsure how to use `seq()` we can search for it in the help window (or typing `help(seq)`). Typing seq and then pressing TAB will automatically give us paired parentheses, which we need for functions.

Type the name of the first argument, `from`, and set it equal to `1`. Then, type the name of the second argument, `to`, and set it equal to `10`.

```{r seq}
seq(from = 1, to = 10)
```

We often omit the names of the first several arguments in function calls, so we can rewrite this as follows:

```{r seq-omit}
seq(1, 10)
```

R also helps us with paired quotation marks e.g., if you type `x <- "`, a pair of quotation marks will appear for you to put a string of characters inside.

```{r hello-world}
x <- "hello world"
```

Quotation marks and parentheses must always come in a pair. RStudio does its best to help you, but it’s still possible to mess up and end up with a mismatch. If this happens, R will show you the continuation character “+”:

`> x <- "hello
+`

The `+` tells you that R is waiting for more input; it doesn’t think you’re done yet. Usually, this means you’ve forgotten either a `"` or a `)`. Either add the missing pair, or press ESCAPE to abort the expression and try again.

## Packages

In order to run the code in this course, we need **4** things. If you've got this far, then you've already got 2 of them sorted: R and Rstudio. R is the actual programming language we're using, which doesn't come installed on your computer by default. R can be downloaded from [https://cloud.r-project.org](https://cloud.r-project.org/). A new major version of R comes out once a year, and there are 2-3 minor releases each year. It’s a good idea to update regularly. Upgrading can be a bit of a hassle, especially for major versions that require you to re-install all your packages, but putting it off only makes it worse.

R comes with a basic integrated development environment, or **IDE**, for programming; however, Rstudio is generally preferred as it comes with more user-friendly built-in features (and looks more like a desktop application which you will be used to). Rstudio can be downloaded from <https://posit.co/download/rstudio-desktop/>. RStudio is updated a couple of times a year, and it will automatically let you know when a new version is out, so there’s no need to check back. It’s a good idea to upgrade regularly to take advantage of the latest and greatest features.

The other **2** things we need are a collection of **packages** called the **tidyverse**, and some other additional packages. An R **package** is a collection of functions, data, and documentation that extends the capabilities of base R. Using packages is key to the successful use of R.

### The tidyverse

The majority of the packages that you will learn in this course are part of the so-called tidyverse. All packages in the tidyverse share a common philosophy of data and R programming and are designed to work together.

We have already installed the tidyverse in our setup code, but the code you would use to install this (or any other package) is a single line:

```{r install-tidyverse}
#| eval: false
install.packages("tidyverse")
```

You will not be able to use the functions, objects, or help files in a package until you load it with `library()`. For example, later on in the course we will be using the package `DESeq2`, but we have not yet installed or loaded this package. If we try to run a function from this package:

```{r deseq-error}
#| error: TRUE
DESeq(dds)
```

We get an error saying "could not find function...".

So, in order to use the tidyverse, we need to load it using `library()`. *Note that when you install packages, you provide the name in quotes. When you load packages, you don't use the quotes.*

```{r tidyverse-library}
library(tidyverse)
```

This tells you that tidyverse loads nine packages: dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble, tidyr. These are considered the **core** of the tidyverse because you’ll use them in almost every analysis.

Packages in the tidyverse change fairly frequently. You can see if updates are available by running `tidyverse_update()`.

### Other packages (KEEP THIS UPDATED)

Other packages which are not part of the tidyverse are designed with a different set of underlying principles. However, they can be very useful for solving problems in a different domain. Honestly, working in R over the few years I have done so, I have come to realise that if I have a problem I can't quite figure out how to do in R, someone has probably already made a package which helps to solve it! (Google is your friend here!).

As you tackle more data science projects with R, you’ll learn new packages and new ways of thinking about data.

We’ll use many packages from outside the tidyverse in this course. For example, we’ll use the following packages because they provide interesting datasets for us to work with in the process of learning R (also notice how you don't have to type out `install.packages()` line-by-line for each package, which would be really tedious! You can use our old friend `c()` to provide a vector of package names surrounded by "" and separated by commas):

```{r other-packages}
#| eval: false
install.packages(
  c("arrow", "babynames", "curl", "duckdb", "gapminder", 
    "ggrepel", "ggridges", "ggthemes", "hexbin", "janitor", "Lahman", 
    "leaflet", "maps", "nycflights13", "openxlsx", "palmerpenguins", 
    "repurrrsive", "tidymodels", "writexl")
  )
```

*Note: we have already installed these in our setup chunk, so there is no need to run the above code right now.*

## Exercises

# Data visualisation

R offers several systems for making graphs, but **ggplot2** is both the most versatile and the most elegant. It’s built on the *grammar of graphics* — a consistent way of describing and constructing plots. By learning this single system, you can quickly create a wide variety of visualisations without having to start from scratch each time.

In this section, you’ll learn how to use ggplot2 to bring your data to life. We’ll begin with a simple scatterplot, introducing the two core ideas that underpin every plot: aesthetic mappings and geometric objects. From there, we’ll explore how to show distributions of single variables and how to visualise relationships between two or more variables. We’ll wrap up with some practical advice on saving your plots and troubleshooting common problems.

As we are short on time, it will not be possible to cover all the features of ggplot2 — in fact, I discover new features every time I use it. There are plenty of great resources out there including this very handy [cheat sheet](https://posit.co/wp-content/uploads/2022/10/data-visualization-1.pdf). Here are a few that I found helpful making this course:

-   [***A ggplot2 tutorial for beautiful plotting in R***](https://www.cedricscherer.com/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/) ***-*** By Cedric Scherer.

-   [***R Graphics Cookbook, 2nd edition***](https://r-graphics.org/index.html) ***-*** By Wiston Chang

-   [***ggplot2: Elegant Graphics for Data Analysis (3e)***](https://ggplot2-book.org/) ***-*** By Hadley Wickham, Danielle Navarro and Thomas Lin Pedersen
